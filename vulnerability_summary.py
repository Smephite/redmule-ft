# Command line tool to sumarize the vulnerability based on a vulnerability output by Injectafault
# Prints a Tree structure with each wire that is vulnerable, something like this:
# i_dut
# - dst_fmt_i                                                                      Faulty [   1/   3] (4: Stall)
# - gen_in_dmr
# - - gen_in_oo_retry
# - - - i_retry_start
# - - - - data_i.op                                                                Faulty [   1/   5] (2: Wrong Output)
# - - - - failed_valid_d                                                           Faulty [   5/   7] (2: Wrong Output)
# - - i_time_DMR_start
# - - - data_i.op                                                                  Faulty [   2/   3] (2: Wrong Output)
# - - - data_i.tag                                                                 Faulty [   1/   5] (2: Wrong Output)
# ...
#
# Usage: python3 vulnerability_summary.py <vulnerability_csv_file>
#
# Author: Maurus Item <itemm@student.ethz.ch>


import csv
import sys

fault_type_dict = {
    1: "State Difference",
    2: "Wrong Output",
    3: "X/Z Output",
    4: "Stall",
    5: "Retry",
    6: "Retry (Unneccesary)",
}


class bcolors:
    HEADER = '\033[95m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    RESET = '\033[0m'
    FAILRED = '\033[91m'


class Node:
    def __init__(self, name):
        self.name = name
        self.children = {}
        self.faults = {}
        self.local_good_count = 0

    def add_fault(self, fault_type: int, seed: int):
        if fault_type > 0:
            self.faults[seed] = fault_type
        else:
            self.local_good_count += 1

    @property
    def local_fault_count(self) -> int:
        return len(self.faults)

    @property
    def fault_count(self) -> int:
        return self.local_fault_count + sum([c.fault_count for c in self.children.values()])

    @property
    def good_count(self) -> int:
        return self.local_good_count + sum([c.good_count for c in self.children.values()])

    @property
    def total_count(self) -> int:
        return self.fault_count + self.good_count

    @property
    def fault_count_per_type(self) -> dict[int: int]:
        # Collect own faults per type
        value_dict = {}
        for fault_type in set(self.faults.values()):
            value_dict[fault_type] = sum(1 for v in self.faults.values() if v == fault_type)

        # Collect faults from children
        for c in self.children.values():
            for ft, ct in c.fault_count_per_type.items():
                value_dict[ft] = value_dict.get(ft, 0) + ct

        return value_dict

def add_net(root, net_name, fault_type, seed, group=False):
    current_node = root

    # Traverse tree
    for segment in net_name.split('/'):

        # Remove same nets with different generate ID
        if group:
            segment = segment.rstrip("[0123456789]")

        if segment not in current_node.children:
            current_node.children[segment] = Node(segment)
        current_node = current_node.children[segment]

    # Add fault to final node
    current_node.add(fault_type, seed)


def extract_vulnerability(injection_report_path: str, root: Node = Node("")) -> Node:
    with open(injection_report_path, newline='') as file:
        reader = csv.DictReader(file)
        for row in reader:

            current_node = root

            # Traverse tree
            for segment in row['injected_net_name'].split('/'):
                if segment not in current_node.children:
                    current_node.children[segment] = Node(segment)
                current_node = current_node.children[segment]

            # Add fault to final node
            current_node.add_fault(int(row['termination_cause']), int(row['seed']))

        file.close()
    return root


def print_vulnerability_tree(node, show_good=False, shown_seeds=6):
    """Prints the entire tree of vulnerabilities"""
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    RESET = '\033[0m'
    FAILRED = '\033[91m'

    stack = [(node, 0)]

    while stack:
        node, level = stack.pop()

        if not show_good and not node.fault_count > 0:
            continue

        # Display the current node with indentation based on its level in the tree
        indent = "- " * level
        tree_str = f"{indent}{node.name}"

        # Find color
        if node.local_fault_count > 0:
            color = FAILRED
        elif node.fault_count > 0:
            color = OKCYAN
        else:
            color = OKGREEN

        # Collect fault_types
        fault_types = ", ".join(f"{k}: {v}" for k, v in node.fault_count_per_type.items())
        if fault_types != "":
            fault_str = f"[{fault_types:10s}]"
        else:
            fault_str = ""

        # Collect seeds
        displayed_seeds = min(len(node.faults), shown_seeds)
        seeds = ", ".join(map(str, sorted(node.faults.keys())[:displayed_seeds]))
        if seeds:
            seed_str = "(Seeds: " + seeds + (", ..." if len(node.faults) > shown_seeds else "") + ")"
        else:
            seed_str = ""

        print(f"{color} {tree_str:80s} [{node.fault_count:4}/{node.total_count:6}] {fault_str} {seed_str} {RESET}")

        # Add children to stack with incremented level
        for child in reversed(node.children.values()):
            stack.append((child, level + 1))

def print_summary(node, fault_type_dict=None):
    """prints a summary of all vulnerabilities in a vulnerability tree"""
    fault_type_dict = fault_type_dict or {
        1: "State Difference",
        2: "Wrong Output",
        3: "X/Z Output",
        4: "Stall",
    }

    print(f"Total Injections: {node.total_count}")
    for fault_id, count in node.fault_count_per_type.items():
        name = fault_type_dict.get(fault_id, f"ID: {fault_id}")
        print(f" - {name}: {count}")
    print(f" - Correct Results: {node.good_count}")


# Filter Redmule type 5 and 6 terminations as they are fine
def redmule_filter_faults(node):
    stack = [node]

    while stack:
        current = stack.pop()

        faults_to_remove = {seed for seed, f_type in current.faults.items() if f_type in {5, 6}}
        current.local_good_count += len(faults_to_remove)

        for seed in faults_to_remove:
            del current.faults[seed]

        # Add children to the stack for further processing
        stack.extend(current.children.values())

redmule_fault_type_dict = {
    1: "State Difference",
    2: "Wrong Output",
    3: "X/Z Output",
    4: "Stall",
    5: "Retry",
    6: "Unneccesary Retry",
}

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python analysis.py <input_csv_file>")
        sys.exit(1)

    csv_file = sys.argv[1]
    tree_root = extract_vulnerability(csv_file, root=Node(""))
    redmule_filter_faults(tree_root)
    print_vulnerability_tree(tree_root, show_good=False)
    print_summary(tree_root, fault_type_dict=redmule_fault_type_dict)
